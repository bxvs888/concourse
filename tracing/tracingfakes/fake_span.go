// Code generated by counterfeiter. DO NOT EDIT.
package tracingfakes

import (
	"sync"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
)

type FakeSpan struct {
	AddEventStub        func(string, ...trace.EventOption)
	addEventMutex       sync.RWMutex
	addEventArgsForCall []struct {
		arg1 string
		arg2 []trace.EventOption
	}
	EndStub        func(...trace.SpanOption)
	endMutex       sync.RWMutex
	endArgsForCall []struct {
		arg1 []trace.SpanOption
	}
	IsRecordingStub        func() bool
	isRecordingMutex       sync.RWMutex
	isRecordingArgsForCall []struct {
	}
	isRecordingReturns struct {
		result1 bool
	}
	isRecordingReturnsOnCall map[int]struct {
		result1 bool
	}
	RecordErrorStub        func(error, ...trace.EventOption)
	recordErrorMutex       sync.RWMutex
	recordErrorArgsForCall []struct {
		arg1 error
		arg2 []trace.EventOption
	}
	SetAttributesStub        func(...attribute.KeyValue)
	setAttributesMutex       sync.RWMutex
	setAttributesArgsForCall []struct {
		arg1 []attribute.KeyValue
	}
	SetNameStub        func(string)
	setNameMutex       sync.RWMutex
	setNameArgsForCall []struct {
		arg1 string
	}
	SetStatusStub        func(codes.Code, string)
	setStatusMutex       sync.RWMutex
	setStatusArgsForCall []struct {
		arg1 codes.Code
		arg2 string
	}
	SpanContextStub        func() trace.SpanContext
	spanContextMutex       sync.RWMutex
	spanContextArgsForCall []struct {
	}
	spanContextReturns struct {
		result1 trace.SpanContext
	}
	spanContextReturnsOnCall map[int]struct {
		result1 trace.SpanContext
	}
	TracerStub        func() trace.Tracer
	tracerMutex       sync.RWMutex
	tracerArgsForCall []struct {
	}
	tracerReturns struct {
		result1 trace.Tracer
	}
	tracerReturnsOnCall map[int]struct {
		result1 trace.Tracer
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSpan) AddEvent(arg1 string, arg2 ...trace.EventOption) {
	fake.addEventMutex.Lock()
	fake.addEventArgsForCall = append(fake.addEventArgsForCall, struct {
		arg1 string
		arg2 []trace.EventOption
	}{arg1, arg2})
	stub := fake.AddEventStub
	fake.recordInvocation("AddEvent", []interface{}{arg1, arg2})
	fake.addEventMutex.Unlock()
	if stub != nil {
		fake.AddEventStub(arg1, arg2...)
	}
}

func (fake *FakeSpan) AddEventCallCount() int {
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	return len(fake.addEventArgsForCall)
}

func (fake *FakeSpan) AddEventCalls(stub func(string, ...trace.EventOption)) {
	fake.addEventMutex.Lock()
	defer fake.addEventMutex.Unlock()
	fake.AddEventStub = stub
}

func (fake *FakeSpan) AddEventArgsForCall(i int) (string, []trace.EventOption) {
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	argsForCall := fake.addEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSpan) End(arg1 ...trace.SpanOption) {
	fake.endMutex.Lock()
	fake.endArgsForCall = append(fake.endArgsForCall, struct {
		arg1 []trace.SpanOption
	}{arg1})
	stub := fake.EndStub
	fake.recordInvocation("End", []interface{}{arg1})
	fake.endMutex.Unlock()
	if stub != nil {
		fake.EndStub(arg1...)
	}
}

func (fake *FakeSpan) EndCallCount() int {
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	return len(fake.endArgsForCall)
}

func (fake *FakeSpan) EndCalls(stub func(...trace.SpanOption)) {
	fake.endMutex.Lock()
	defer fake.endMutex.Unlock()
	fake.EndStub = stub
}

func (fake *FakeSpan) EndArgsForCall(i int) []trace.SpanOption {
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	argsForCall := fake.endArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpan) IsRecording() bool {
	fake.isRecordingMutex.Lock()
	ret, specificReturn := fake.isRecordingReturnsOnCall[len(fake.isRecordingArgsForCall)]
	fake.isRecordingArgsForCall = append(fake.isRecordingArgsForCall, struct {
	}{})
	stub := fake.IsRecordingStub
	fakeReturns := fake.isRecordingReturns
	fake.recordInvocation("IsRecording", []interface{}{})
	fake.isRecordingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpan) IsRecordingCallCount() int {
	fake.isRecordingMutex.RLock()
	defer fake.isRecordingMutex.RUnlock()
	return len(fake.isRecordingArgsForCall)
}

func (fake *FakeSpan) IsRecordingCalls(stub func() bool) {
	fake.isRecordingMutex.Lock()
	defer fake.isRecordingMutex.Unlock()
	fake.IsRecordingStub = stub
}

func (fake *FakeSpan) IsRecordingReturns(result1 bool) {
	fake.isRecordingMutex.Lock()
	defer fake.isRecordingMutex.Unlock()
	fake.IsRecordingStub = nil
	fake.isRecordingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSpan) IsRecordingReturnsOnCall(i int, result1 bool) {
	fake.isRecordingMutex.Lock()
	defer fake.isRecordingMutex.Unlock()
	fake.IsRecordingStub = nil
	if fake.isRecordingReturnsOnCall == nil {
		fake.isRecordingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isRecordingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSpan) RecordError(arg1 error, arg2 ...trace.EventOption) {
	fake.recordErrorMutex.Lock()
	fake.recordErrorArgsForCall = append(fake.recordErrorArgsForCall, struct {
		arg1 error
		arg2 []trace.EventOption
	}{arg1, arg2})
	stub := fake.RecordErrorStub
	fake.recordInvocation("RecordError", []interface{}{arg1, arg2})
	fake.recordErrorMutex.Unlock()
	if stub != nil {
		fake.RecordErrorStub(arg1, arg2...)
	}
}

func (fake *FakeSpan) RecordErrorCallCount() int {
	fake.recordErrorMutex.RLock()
	defer fake.recordErrorMutex.RUnlock()
	return len(fake.recordErrorArgsForCall)
}

func (fake *FakeSpan) RecordErrorCalls(stub func(error, ...trace.EventOption)) {
	fake.recordErrorMutex.Lock()
	defer fake.recordErrorMutex.Unlock()
	fake.RecordErrorStub = stub
}

func (fake *FakeSpan) RecordErrorArgsForCall(i int) (error, []trace.EventOption) {
	fake.recordErrorMutex.RLock()
	defer fake.recordErrorMutex.RUnlock()
	argsForCall := fake.recordErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSpan) SetAttributes(arg1 ...attribute.KeyValue) {
	fake.setAttributesMutex.Lock()
	fake.setAttributesArgsForCall = append(fake.setAttributesArgsForCall, struct {
		arg1 []attribute.KeyValue
	}{arg1})
	stub := fake.SetAttributesStub
	fake.recordInvocation("SetAttributes", []interface{}{arg1})
	fake.setAttributesMutex.Unlock()
	if stub != nil {
		fake.SetAttributesStub(arg1...)
	}
}

func (fake *FakeSpan) SetAttributesCallCount() int {
	fake.setAttributesMutex.RLock()
	defer fake.setAttributesMutex.RUnlock()
	return len(fake.setAttributesArgsForCall)
}

func (fake *FakeSpan) SetAttributesCalls(stub func(...attribute.KeyValue)) {
	fake.setAttributesMutex.Lock()
	defer fake.setAttributesMutex.Unlock()
	fake.SetAttributesStub = stub
}

func (fake *FakeSpan) SetAttributesArgsForCall(i int) []attribute.KeyValue {
	fake.setAttributesMutex.RLock()
	defer fake.setAttributesMutex.RUnlock()
	argsForCall := fake.setAttributesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpan) SetName(arg1 string) {
	fake.setNameMutex.Lock()
	fake.setNameArgsForCall = append(fake.setNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetNameStub
	fake.recordInvocation("SetName", []interface{}{arg1})
	fake.setNameMutex.Unlock()
	if stub != nil {
		fake.SetNameStub(arg1)
	}
}

func (fake *FakeSpan) SetNameCallCount() int {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	return len(fake.setNameArgsForCall)
}

func (fake *FakeSpan) SetNameCalls(stub func(string)) {
	fake.setNameMutex.Lock()
	defer fake.setNameMutex.Unlock()
	fake.SetNameStub = stub
}

func (fake *FakeSpan) SetNameArgsForCall(i int) string {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	argsForCall := fake.setNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpan) SetStatus(arg1 codes.Code, arg2 string) {
	fake.setStatusMutex.Lock()
	fake.setStatusArgsForCall = append(fake.setStatusArgsForCall, struct {
		arg1 codes.Code
		arg2 string
	}{arg1, arg2})
	stub := fake.SetStatusStub
	fake.recordInvocation("SetStatus", []interface{}{arg1, arg2})
	fake.setStatusMutex.Unlock()
	if stub != nil {
		fake.SetStatusStub(arg1, arg2)
	}
}

func (fake *FakeSpan) SetStatusCallCount() int {
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	return len(fake.setStatusArgsForCall)
}

func (fake *FakeSpan) SetStatusCalls(stub func(codes.Code, string)) {
	fake.setStatusMutex.Lock()
	defer fake.setStatusMutex.Unlock()
	fake.SetStatusStub = stub
}

func (fake *FakeSpan) SetStatusArgsForCall(i int) (codes.Code, string) {
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	argsForCall := fake.setStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSpan) SpanContext() trace.SpanContext {
	fake.spanContextMutex.Lock()
	ret, specificReturn := fake.spanContextReturnsOnCall[len(fake.spanContextArgsForCall)]
	fake.spanContextArgsForCall = append(fake.spanContextArgsForCall, struct {
	}{})
	stub := fake.SpanContextStub
	fakeReturns := fake.spanContextReturns
	fake.recordInvocation("SpanContext", []interface{}{})
	fake.spanContextMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpan) SpanContextCallCount() int {
	fake.spanContextMutex.RLock()
	defer fake.spanContextMutex.RUnlock()
	return len(fake.spanContextArgsForCall)
}

func (fake *FakeSpan) SpanContextCalls(stub func() trace.SpanContext) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = stub
}

func (fake *FakeSpan) SpanContextReturns(result1 trace.SpanContext) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = nil
	fake.spanContextReturns = struct {
		result1 trace.SpanContext
	}{result1}
}

func (fake *FakeSpan) SpanContextReturnsOnCall(i int, result1 trace.SpanContext) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = nil
	if fake.spanContextReturnsOnCall == nil {
		fake.spanContextReturnsOnCall = make(map[int]struct {
			result1 trace.SpanContext
		})
	}
	fake.spanContextReturnsOnCall[i] = struct {
		result1 trace.SpanContext
	}{result1}
}

func (fake *FakeSpan) Tracer() trace.Tracer {
	fake.tracerMutex.Lock()
	ret, specificReturn := fake.tracerReturnsOnCall[len(fake.tracerArgsForCall)]
	fake.tracerArgsForCall = append(fake.tracerArgsForCall, struct {
	}{})
	stub := fake.TracerStub
	fakeReturns := fake.tracerReturns
	fake.recordInvocation("Tracer", []interface{}{})
	fake.tracerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpan) TracerCallCount() int {
	fake.tracerMutex.RLock()
	defer fake.tracerMutex.RUnlock()
	return len(fake.tracerArgsForCall)
}

func (fake *FakeSpan) TracerCalls(stub func() trace.Tracer) {
	fake.tracerMutex.Lock()
	defer fake.tracerMutex.Unlock()
	fake.TracerStub = stub
}

func (fake *FakeSpan) TracerReturns(result1 trace.Tracer) {
	fake.tracerMutex.Lock()
	defer fake.tracerMutex.Unlock()
	fake.TracerStub = nil
	fake.tracerReturns = struct {
		result1 trace.Tracer
	}{result1}
}

func (fake *FakeSpan) TracerReturnsOnCall(i int, result1 trace.Tracer) {
	fake.tracerMutex.Lock()
	defer fake.tracerMutex.Unlock()
	fake.TracerStub = nil
	if fake.tracerReturnsOnCall == nil {
		fake.tracerReturnsOnCall = make(map[int]struct {
			result1 trace.Tracer
		})
	}
	fake.tracerReturnsOnCall[i] = struct {
		result1 trace.Tracer
	}{result1}
}

func (fake *FakeSpan) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	fake.isRecordingMutex.RLock()
	defer fake.isRecordingMutex.RUnlock()
	fake.recordErrorMutex.RLock()
	defer fake.recordErrorMutex.RUnlock()
	fake.setAttributesMutex.RLock()
	defer fake.setAttributesMutex.RUnlock()
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	fake.spanContextMutex.RLock()
	defer fake.spanContextMutex.RUnlock()
	fake.tracerMutex.RLock()
	defer fake.tracerMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSpan) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ trace.Span = new(FakeSpan)
